# Autogenerated wrapper script for CUDA_jll for x86_64-apple-darwin14
export libcublas, libcublasLt, libcudadevrt, libcudart, libcufft, libcufftw, libcupti, libcurand, libcurand, libcusolver, libcusolverMg, libcusparse, libdevice, libnppc, libnppial, libnppicc, libnppicom, libnppidei, libnppif, libnppig, libnppim, libnppist, libnppisu, libnppitc, libnpps, libnvblas, libnvtoolsext, libnvvm, nvdisasm

## Global variables
PATH = ""
LIBPATH = ""
LIBPATH_env = "DYLD_FALLBACK_LIBRARY_PATH"
LIBPATH_default = "~/lib:/usr/local/lib:/lib:/usr/lib"

# Relative path to `libcublas`
const libcublas_splitpath = ["lib", "libcublas.10.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libcublas_path = ""

# libcublas-specific global declaration
# This will be filled out by __init__()
libcublas_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libcublas = "@rpath/libcublas.10.dylib"


# Relative path to `libcublasLt`
const libcublasLt_splitpath = ["lib", "libcublasLt.10.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libcublasLt_path = ""

# libcublasLt-specific global declaration
# This will be filled out by __init__()
libcublasLt_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libcublasLt = "@rpath/libcublasLt.10.dylib"


# Relative path to `libcudadevrt`
const libcudadevrt_splitpath = ["lib", "libcudadevrt.a"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libcudadevrt_path = ""

# libcudadevrt-specific global declaration
# This will be filled out by __init__()
libcudadevrt = ""


# Relative path to `libcudart`
const libcudart_splitpath = ["lib", "libcudart.10.1.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libcudart_path = ""

# libcudart-specific global declaration
# This will be filled out by __init__()
libcudart_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libcudart = "@rpath/libcudart.10.1.dylib"


# Relative path to `libcufft`
const libcufft_splitpath = ["lib", "libcufft.10.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libcufft_path = ""

# libcufft-specific global declaration
# This will be filled out by __init__()
libcufft_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libcufft = "@rpath/libcufft.10.dylib"


# Relative path to `libcufftw`
const libcufftw_splitpath = ["lib", "libcufftw.10.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libcufftw_path = ""

# libcufftw-specific global declaration
# This will be filled out by __init__()
libcufftw_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libcufftw = "@rpath/libcufftw.10.dylib"


# Relative path to `libcupti`
const libcupti_splitpath = ["lib", "libcupti.10.1.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libcupti_path = ""

# libcupti-specific global declaration
# This will be filled out by __init__()
libcupti_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libcupti = "@rpath/libcupti.10.1.dylib"


# Relative path to `libcurand`
const libcurand_splitpath = ["lib", "libcurand.10.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libcurand_path = ""

# libcurand-specific global declaration
# This will be filled out by __init__()
libcurand_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libcurand = "@rpath/libcurand.10.dylib"


# Relative path to `libcurand`
const libcurand_splitpath = ["lib", "libnvgraph.10.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libcurand_path = ""

# libcurand-specific global declaration
# This will be filled out by __init__()
libcurand_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libcurand = "@rpath/libnvgraph.10.dylib"


# Relative path to `libcusolver`
const libcusolver_splitpath = ["lib", "libcusolver.10.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libcusolver_path = ""

# libcusolver-specific global declaration
# This will be filled out by __init__()
libcusolver_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libcusolver = "@rpath/libcusolver.10.dylib"


# Relative path to `libcusolverMg`
const libcusolverMg_splitpath = ["lib", "libcusolverMg.10.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libcusolverMg_path = ""

# libcusolverMg-specific global declaration
# This will be filled out by __init__()
libcusolverMg_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libcusolverMg = "@rpath/libcusolverMg.10.dylib"


# Relative path to `libcusparse`
const libcusparse_splitpath = ["lib", "libcusparse.10.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libcusparse_path = ""

# libcusparse-specific global declaration
# This will be filled out by __init__()
libcusparse_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libcusparse = "@rpath/libcusparse.10.dylib"


# Relative path to `libdevice`
const libdevice_splitpath = ["share", "libdevice", "libdevice.10.bc"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libdevice_path = ""

# libdevice-specific global declaration
# This will be filled out by __init__()
libdevice = ""


# Relative path to `libnppc`
const libnppc_splitpath = ["lib", "libnppc.10.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libnppc_path = ""

# libnppc-specific global declaration
# This will be filled out by __init__()
libnppc_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libnppc = "@rpath/libnppc.10.dylib"


# Relative path to `libnppial`
const libnppial_splitpath = ["lib", "libnppial.10.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libnppial_path = ""

# libnppial-specific global declaration
# This will be filled out by __init__()
libnppial_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libnppial = "@rpath/libnppial.10.dylib"


# Relative path to `libnppicc`
const libnppicc_splitpath = ["lib", "libnppicc.10.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libnppicc_path = ""

# libnppicc-specific global declaration
# This will be filled out by __init__()
libnppicc_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libnppicc = "@rpath/libnppicc.10.dylib"


# Relative path to `libnppicom`
const libnppicom_splitpath = ["lib", "libnppicom.10.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libnppicom_path = ""

# libnppicom-specific global declaration
# This will be filled out by __init__()
libnppicom_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libnppicom = "@rpath/libnppicom.10.dylib"


# Relative path to `libnppidei`
const libnppidei_splitpath = ["lib", "libnppidei.10.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libnppidei_path = ""

# libnppidei-specific global declaration
# This will be filled out by __init__()
libnppidei_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libnppidei = "@rpath/libnppidei.10.dylib"


# Relative path to `libnppif`
const libnppif_splitpath = ["lib", "libnppif.10.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libnppif_path = ""

# libnppif-specific global declaration
# This will be filled out by __init__()
libnppif_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libnppif = "@rpath/libnppif.10.dylib"


# Relative path to `libnppig`
const libnppig_splitpath = ["lib", "libnppig.10.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libnppig_path = ""

# libnppig-specific global declaration
# This will be filled out by __init__()
libnppig_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libnppig = "@rpath/libnppig.10.dylib"


# Relative path to `libnppim`
const libnppim_splitpath = ["lib", "libnppim.10.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libnppim_path = ""

# libnppim-specific global declaration
# This will be filled out by __init__()
libnppim_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libnppim = "@rpath/libnppim.10.dylib"


# Relative path to `libnppist`
const libnppist_splitpath = ["lib", "libnppist.10.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libnppist_path = ""

# libnppist-specific global declaration
# This will be filled out by __init__()
libnppist_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libnppist = "@rpath/libnppist.10.dylib"


# Relative path to `libnppisu`
const libnppisu_splitpath = ["lib", "libnppisu.10.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libnppisu_path = ""

# libnppisu-specific global declaration
# This will be filled out by __init__()
libnppisu_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libnppisu = "@rpath/libnppisu.10.dylib"


# Relative path to `libnppitc`
const libnppitc_splitpath = ["lib", "libnppitc.10.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libnppitc_path = ""

# libnppitc-specific global declaration
# This will be filled out by __init__()
libnppitc_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libnppitc = "@rpath/libnppitc.10.dylib"


# Relative path to `libnpps`
const libnpps_splitpath = ["lib", "libnpps.10.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libnpps_path = ""

# libnpps-specific global declaration
# This will be filled out by __init__()
libnpps_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libnpps = "@rpath/libnpps.10.dylib"


# Relative path to `libnvblas`
const libnvblas_splitpath = ["lib", "libnvblas.10.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libnvblas_path = ""

# libnvblas-specific global declaration
# This will be filled out by __init__()
libnvblas_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libnvblas = "@rpath/libnvblas.10.dylib"


# Relative path to `libnvtoolsext`
const libnvtoolsext_splitpath = ["lib", "libnvToolsExt.1.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libnvtoolsext_path = ""

# libnvtoolsext-specific global declaration
# This will be filled out by __init__()
libnvtoolsext_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libnvtoolsext = "@rpath/libnvToolsExt.1.dylib"


# Relative path to `libnvvm`
const libnvvm_splitpath = ["lib", "libnvvm.3.3.0.dylib"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libnvvm_path = ""

# libnvvm-specific global declaration
# This will be filled out by __init__()
libnvvm_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libnvvm = "@rpath/libnvvm.3.3.0.dylib"


# Relative path to `nvdisasm`
const nvdisasm_splitpath = ["bin", "nvdisasm"]

# This will be filled out by __init__() for all products, as it must be done at runtime
nvdisasm_path = ""

# nvdisasm-specific global declaration
function nvdisasm(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(nvdisasm_path)
    end
end


"""
Open all libraries
"""
function __init__()
    global artifact_dir = abspath(artifact"CUDA")

    # Initialize PATH and LIBPATH environment variable listings
    global PATH_list, LIBPATH_list
    global libcublas_path = normpath(joinpath(artifact_dir, libcublas_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libcublas_handle = dlopen(libcublas_path)
    push!(LIBPATH_list, dirname(libcublas_path))

    global libcublasLt_path = normpath(joinpath(artifact_dir, libcublasLt_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libcublasLt_handle = dlopen(libcublasLt_path)
    push!(LIBPATH_list, dirname(libcublasLt_path))

    global libcudadevrt_path = normpath(joinpath(artifact_dir, libcudadevrt_splitpath...))

    global libcudadevrt = libcudadevrt_path
    global libcudart_path = normpath(joinpath(artifact_dir, libcudart_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libcudart_handle = dlopen(libcudart_path)
    push!(LIBPATH_list, dirname(libcudart_path))

    global libcufft_path = normpath(joinpath(artifact_dir, libcufft_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libcufft_handle = dlopen(libcufft_path)
    push!(LIBPATH_list, dirname(libcufft_path))

    global libcufftw_path = normpath(joinpath(artifact_dir, libcufftw_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libcufftw_handle = dlopen(libcufftw_path)
    push!(LIBPATH_list, dirname(libcufftw_path))

    global libcupti_path = normpath(joinpath(artifact_dir, libcupti_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libcupti_handle = dlopen(libcupti_path)
    push!(LIBPATH_list, dirname(libcupti_path))

    global libcurand_path = normpath(joinpath(artifact_dir, libcurand_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libcurand_handle = dlopen(libcurand_path)
    push!(LIBPATH_list, dirname(libcurand_path))

    global libcurand_path = normpath(joinpath(artifact_dir, libcurand_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libcurand_handle = dlopen(libcurand_path)
    push!(LIBPATH_list, dirname(libcurand_path))

    global libcusolver_path = normpath(joinpath(artifact_dir, libcusolver_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libcusolver_handle = dlopen(libcusolver_path)
    push!(LIBPATH_list, dirname(libcusolver_path))

    global libcusolverMg_path = normpath(joinpath(artifact_dir, libcusolverMg_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libcusolverMg_handle = dlopen(libcusolverMg_path)
    push!(LIBPATH_list, dirname(libcusolverMg_path))

    global libcusparse_path = normpath(joinpath(artifact_dir, libcusparse_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libcusparse_handle = dlopen(libcusparse_path)
    push!(LIBPATH_list, dirname(libcusparse_path))

    global libdevice_path = normpath(joinpath(artifact_dir, libdevice_splitpath...))

    global libdevice = libdevice_path
    global libnppc_path = normpath(joinpath(artifact_dir, libnppc_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libnppc_handle = dlopen(libnppc_path)
    push!(LIBPATH_list, dirname(libnppc_path))

    global libnppial_path = normpath(joinpath(artifact_dir, libnppial_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libnppial_handle = dlopen(libnppial_path)
    push!(LIBPATH_list, dirname(libnppial_path))

    global libnppicc_path = normpath(joinpath(artifact_dir, libnppicc_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libnppicc_handle = dlopen(libnppicc_path)
    push!(LIBPATH_list, dirname(libnppicc_path))

    global libnppicom_path = normpath(joinpath(artifact_dir, libnppicom_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libnppicom_handle = dlopen(libnppicom_path)
    push!(LIBPATH_list, dirname(libnppicom_path))

    global libnppidei_path = normpath(joinpath(artifact_dir, libnppidei_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libnppidei_handle = dlopen(libnppidei_path)
    push!(LIBPATH_list, dirname(libnppidei_path))

    global libnppif_path = normpath(joinpath(artifact_dir, libnppif_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libnppif_handle = dlopen(libnppif_path)
    push!(LIBPATH_list, dirname(libnppif_path))

    global libnppig_path = normpath(joinpath(artifact_dir, libnppig_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libnppig_handle = dlopen(libnppig_path)
    push!(LIBPATH_list, dirname(libnppig_path))

    global libnppim_path = normpath(joinpath(artifact_dir, libnppim_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libnppim_handle = dlopen(libnppim_path)
    push!(LIBPATH_list, dirname(libnppim_path))

    global libnppist_path = normpath(joinpath(artifact_dir, libnppist_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libnppist_handle = dlopen(libnppist_path)
    push!(LIBPATH_list, dirname(libnppist_path))

    global libnppisu_path = normpath(joinpath(artifact_dir, libnppisu_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libnppisu_handle = dlopen(libnppisu_path)
    push!(LIBPATH_list, dirname(libnppisu_path))

    global libnppitc_path = normpath(joinpath(artifact_dir, libnppitc_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libnppitc_handle = dlopen(libnppitc_path)
    push!(LIBPATH_list, dirname(libnppitc_path))

    global libnpps_path = normpath(joinpath(artifact_dir, libnpps_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libnpps_handle = dlopen(libnpps_path)
    push!(LIBPATH_list, dirname(libnpps_path))

    global libnvblas_path = normpath(joinpath(artifact_dir, libnvblas_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libnvblas_handle = dlopen(libnvblas_path)
    push!(LIBPATH_list, dirname(libnvblas_path))

    global libnvtoolsext_path = normpath(joinpath(artifact_dir, libnvtoolsext_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libnvtoolsext_handle = dlopen(libnvtoolsext_path)
    push!(LIBPATH_list, dirname(libnvtoolsext_path))

    global libnvvm_path = normpath(joinpath(artifact_dir, libnvvm_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libnvvm_handle = dlopen(libnvvm_path)
    push!(LIBPATH_list, dirname(libnvvm_path))

    global nvdisasm_path = normpath(joinpath(artifact_dir, nvdisasm_splitpath...))

    push!(PATH_list, dirname(nvdisasm_path))
    # Filter out duplicate and empty entries in our PATH and LIBPATH entries
    filter!(!isempty, unique!(PATH_list))
    filter!(!isempty, unique!(LIBPATH_list))
    global PATH = join(PATH_list, ':')
    global LIBPATH = join(vcat(LIBPATH_list, [joinpath(Sys.BINDIR, Base.LIBDIR, "julia"), joinpath(Sys.BINDIR, Base.LIBDIR)]), ':')

    
end  # __init__()

